@using Microsoft.JSInterop
@inject IJSRuntime JSRuntime

@if (Anchor is not null)
{
    <span style="display: inline-block" @ref="_anchorRef">
        @Anchor
    </span>
}

@if (Open)
{
    <PopperPortal>
        <span @ref="_contentRef">
            @Content
        </span>
    </PopperPortal>
}


@code {
    [Parameter] public RenderFragment? Anchor { get; set; }
    [Parameter, EditorRequired] public RenderFragment Content { get; set; } = default!;
    [Parameter] public bool AutoClose { get; set; }
    [Parameter] public (int x, int y)? Offset { get; set; }
    [Parameter] public Modifier[] Modifiers { get; set; } = { };

    [Parameter] public bool Open { get; set; }
    [Parameter] public EventCallback<bool> OpenChanged { get; set; }
    private bool _wasOpen;

    [Parameter] public Placement Placement { get; set; }
    private Placement? _previousPlacement;

    private ElementReference? _anchorRef;
    private ElementReference? _contentRef;

    private PopperInterop _popperInterop;

    protected override void OnInitialized()
    {
        _popperInterop = new PopperInterop(JSRuntime);
        _popperInterop.OnClosed += HidePopper;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        //hacky bullshit
        await Task.Yield();
        
        if (Open && !_wasOpen)
        {
            await _popperInterop.Create(_anchorRef, _contentRef!.Value, Placement, GetModifiers(), AutoClose);
        }

        _wasOpen = Open;
        _previousPlacement = Placement;
    }

    private Modifier[] GetModifiers()
    {
        var modifiers = new List<Modifier>(Modifiers);
        if (Offset.HasValue)
        {
            modifiers.Add(new OffsetModifier(Offset.Value.x, Offset.Value.y));
        }
        return modifiers.ToArray();
    }

    private async Task HidePopper()
    {
        Open = false;
        await OpenChanged.InvokeAsync(Open);
        StateHasChanged();
    }

}
